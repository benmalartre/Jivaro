#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchema.  DO NOT EDIT."
)

class PbdSolver "PbdSolver" (
    apiSchemas = ["CollectionAPI:colliders, CollectionAPI:bodies"]
    doc = "Defines position based dynamics solver."
)
{
    rel pbd:bodies (
        displayName = "Bodies"
        doc = "Simulate Body List"
    )
    rel pbd:colliders (
        displayName = "Colliders"
        doc = "Collider Object List"
    )
    vector3f pbd:gravity = (0, -9.8, 0) (
        displayName = "Gravity"
        doc = "Gravity vector in simulation solver space"
    )
    bool pbd:showConstraints = 1 (
        displayName = "Show Constraints"
        doc = "Display constraints in viewport"
    )
    bool pbd:showPoints = 1 (
        displayName = "Show Points"
        doc = "Display particles in viewport"
    )
    float pbd:sleepThreshold = 0.001 (
        displayName = "Sleep Threshold"
        doc = "Sleep threshold"
    )
    int pbd:startFrame = 1 (
        displayName = "Start Frame"
        doc = "Simulation start frame"
    )
    int pbd:subSteps = 8 (
        displayName = "SubSteps"
        doc = "Num substeps per frame"
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "PbdBodyAPI" (
    doc = "Applies soft body attributes to a deformable prim."
)
{
    float pbd:damp = 0.1 (
        displayName = "Damp"
        doc = "damp coefficient."
    )
    float pbd:mass = 1 (
        displayName = "Mass"
        doc = "friction coefficient."
    )
    float pbd:radius = 0.1 (
        displayName = "Radius"
        doc = "particle radius used by collision detection."
    )
    float pbd:selfCollisionDamp = 0.1 (
        displayName = "Self Collision Damp"
        doc = "self collision damp coefficient."
    )
    bool pbd:selfCollisionEnabled = 1 (
        displayName = "Self Collision Enabled"
        doc = "self collision detection active state."
    )
    float pbd:selfCollisionFriction = 0.2 (
        displayName = "Self Collision Friction"
        doc = "self collision friction coefficient."
    )
    float pbd:selfCollisionMaxSeparationVelocity = 5 (
        displayName = "Self Collision Maximum Separation Velocity"
        doc = "Self Collision Maximum separation velocity."
    )
    float pbd:selfCollisionRadius = 1 (
        displayName = "Self Collision Radius"
        doc = "particle radius used by self collision detection."
    )
    float pbd:selfCollisionRestitution = 0 (
        displayName = "Self Collision Restitution"
        doc = "Self COllision Restitution coefficient."
    )
    bool pbd:simulationEnabled = 1 (
        displayName = "Simulation Enabled"
        doc = "Determines if the PbdBodyAPI is enabled."
    )
    vector3f pbd:velocity = (0, 0, 0) (
        displayName = "Velocity"
        doc = "Velocity vector in simulation solver space"
    )
}

class "PbdCollisionAPI" (
    doc = "Applies position based dynamics collision attributes to a UsdGeomXformable prim."
)
{
    float pbd:collisionDamp = 0.25 (
        displayName = "Damp"
        doc = "collision constraint damp."
    )
    bool pbd:collisionEnabled = 1 (
        displayName = "Enabled"
        doc = "Determines if the PbdCollisionAPI is enabled."
    )
    float pbd:collisionStiffness = 0 (
        displayName = "Collision Stiffness"
        doc = "collision constraint stiffness."
    )
    float pbd:friction = 0.2 (
        displayName = "Friction"
        doc = "friction coefficient."
    )
    float pbd:margin = 0.05 (
        displayName = "Margin"
        doc = "extend search radius by margin for safer collision detection."
    )
    float pbd:maxSeparationVelocity = 5 (
        displayName = "Maximum Separation Velocity"
        doc = "Maximum separation velocity."
    )
    float pbd:restitution = 0 (
        displayName = "Restitution"
        doc = "Restitution coefficient."
    )
}

class "PbdConstraintAPI" (
    doc = "Applies position based dynamics constraint attributes to a deformable prim(s)."
)
{
    bool pbd:constraint:__INSTANCE_NAME__:constraintEnabled = 1 (
        displayName = "Constraint Enabled"
        doc = "Determines if the PbdConstraintAPI is enabled."
    )
    float pbd:constraint:__INSTANCE_NAME__:damp = 0.2 (
        displayName = "Damp"
        doc = "Damp coefficient. Unitless."
    )
    float pbd:constraint:__INSTANCE_NAME__:stiffness = 10000 (
        displayName = "Stiffness"
        doc = "stiffness coefficient. Unitless."
    )
}

