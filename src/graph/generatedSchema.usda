#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED.  DO NOT EDIT."
    customLayerData = {
        string[] appliedAPISchemas = ["DeformableAPI"]
        dictionary multipleApplyAPISchemas = {
        }
    }
)

class Graph "Graph" (
    doc = '''A node-graph is a container for asset nodes, as well as other \r
  node-graphs. It has a public input interface and provides a list of public \r
  outputs.\r
\r
  <b>Node Graph Interfaces</b>\r
  \r
  One of the most important functions of a node-graph is to host the "interface"\r
  with which clients of already-built nodes networks will interact.  Please\r
  see "Interface Inputs" for a detailed\r
  explanation of what the interface provides, and how to construct and\r
  use it, to effectively share/instance nodes networks.\r
\r
  <b>Node Graph Ports</b>\r
\r
  These are typically connected to an input on a other node inside the node-graph.\r
  These are also used to author and animate input parameters.\r
  '''
)
{
}

class Node "Node" (
    doc = """Base class for all Amnesia Nodes.\r
    """
)
{
}

class Stage "Stage" (
    doc = "Class for the terminal stage node"
)
{
    uniform string fileName (
        doc = "ar-solvable file path on disk"
    )
    token[] inputs:layers (
        doc = "Relationships to the layers composing this stage."
    )
    uniform token lifetimeManagement (
        allowedTokens = ["on-disk", "in-memory"]
        doc = """Encodes the lifetime management of the stage, on-disk or\r
        in-memory"""
    )
    uniform string[] loadPrimsPath (
        doc = """Full Path to prims on the stage.\r
        These prims will be associated with state below on loading the stage.\r
        """
    )
    uniform token[] loadPrimsStates (
        allowedTokens = ["AllRule", "OnlyRule", "NoneRule"]
        doc = """Load rule for the associated prim.\r
            - AllRule : Include payloads on the specified prim and all \r
              descendants.\r
            - OnlyRule : Include payloads on the specified prim but no \r
              descendants.\r
            - NoneRule : Exclude payloads on the specified prim and all \r
              descendants.\r
        """
    )
    uniform string[] populationMask (
        doc = """Set of fullpath to prims on the stage.\r
            This set represents a mask that may be applied to a stage to limit \r
            the prims it populates.\r
        """
    )
}

class Deformable "Deformable" (
    doc = """A Deformable provides a hub into which multiple layers are \r
  composed according to the node state and provide deformed geometry over \r
  time to upstream the pipeline.\r
  """
)
{
    token inputs:geometry (
        displayGroup = "Inputs"
        doc = "Describes the <i>input geometry</i> input on a Deformable."
    )
    token outputs:deformed (
        displayGroup = "Outputs"
        doc = "Describes the <i>result geometry</i> output on a AssetNode."
    )
}

class Layer "Layer" (
    doc = """Class for the layer node.\r
      A layer is a unit of scene description that you combine with other units\r
      of scene description to form a shot, model, set, shader, and so on.\r
    """
)
{
    uniform string fileName (
        doc = "ar-solvable file path on disk"
    )
    token[] outputs:result (
        displayGroup = "Outputs"
        doc = "loaded result for this layer."
    )
}

class "ConnectableAPI" (
    doc = """ConnectableAPI is an API schema that provides a common\r
  interface for creating outputs and making connections between nodes.\r
  The interface is common to all Graph schemas including Node, Graph, \r
  and Deformable.\r
\r
  One can construct a ConnectableAPI directly from a UsdPrim, or\r
  from objects of any of the schema classes listed above.  If it seems\r
  onerous to need to construct a secondary schema object to interact with\r
  Inputs and Outputs, keep in mind that any function whose purpose is either\r
  to walk shot description networks via their connections, or to create such\r
  networks, can typically be written entirely in terms of \r
  ConnectableAPI objects, without needing to care what the underlying\r
  prim type is.\r
\r
  Additionally, the most common ConnectableAPI behaviors\r
  (creating Inputs and Outputs, and making connections) are wrapped as\r
  convenience methods on the prim schema classes (creation) and \r
  InputPort and OutputPort.\r
  """
)
{
}

class "DeformableAPI" (
    doc = """DeformableAPI is an API schema that provides an \r
  interface for binding assets to different states(animation, cfx, cached...). \r
  """
)
{
}

class "CoordSysAPI" (
    doc = '''CoordSysAPI provides a way to designate, name,\r
    and discover coordinate systems.\r
\r
    Coordinate systems are implicitly established by UsdGeomXformable\r
    prims, using their local space.  That coordinate system may be\r
    bound (i.e., named) from another prim.  The binding is encoded\r
    as a single-target relationship in the "coordSys:" namespace.\r
    Coordinate system bindings apply to descendants of the prim\r
    where the binding is expressed, but names may be re-bound by\r
    descendant prims.\r
\r
    Named coordinate systems are useful in animation workflows.\r
    An example is camera base sculpting.  \r
    Using the paint coordinate frame avoids the need to assign \r
    a UV set to the object, and can be a concise way to project\r
    sculpt across a collection of objects with a single shared\r
    paint coordinate system.\r
\r
    This is a non-applied API schema.\r
    '''
)
{
}

