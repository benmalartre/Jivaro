#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED.  DO NOT EDIT."
    customLayerData = {
        string[] appliedAPISchemas = ["ComposerBindingAPI"]
        string[] multipleApplyAPISchemas = []
    }
)

class NodeGraph "NodeGraph" (
    doc = '''A node-graph is a container for asset nodes, as well as other 
  node-graphs. It has a public input interface and provides a list of public 
  outputs.

  <b>Node Graph Interfaces</b>
  
  One of the most important functions of a node-graph is to host the "interface"
  with which clients of already-built nodes networks will interact.  Please
  see "Interface Inputs" for a detailed
  explanation of what the interface provides, and how to construct and
  use it, to effectively share/instance nodes networks.

  <b>Node Graph Ports</b>

  These are typically connected to an input on a other node inside the node-graph.
  These are also used to author and animate input parameters.
  '''
)
{
}

class NodeComposer "NodeComposer" (
    doc = '''A NodeComposer provides a container into which multiple "assets"
  can add data that defines datas to upstream the pipeline.  Typically
  this consists of one or more UsdRelationship properties that target
  other prims of type Asset - though a target/client is free to add
  any data that is suitable.  We <b>strongly advise</b> that all targets
  adopt the convention that all properties be prefixed with a namespace
  that identifies the target, e.g. "rel Bob:geom = </Geometry/Head>".
  '''
)
{
    token outputs:deformed (
        displayGroup = "Outputs"
        doc = "Describes the <i>deformed geometry</i> output terminal on a NodeComposer."
    )
}

class Node "Node" (
    doc = '''Base class for all Nodes. Nodes are the building blocks
  of deformation networks.
  
  Objects of this class generally represent a single object, whether
  it exists in the target renderer or not. For example, a geometry, a manipulator,
  or a computation node...

  The main property of this class is the info:id token, which uniquely 
  identifies the type of this node.

  The purpose of representing them in Usd is two-fold:
  - To represent, via "connections" the topology of the deformation network
  that must be reconstructed in the client application. Facilities for authoring and 
  manipulating connections are encapsulated in the Has-A schema ConnectableAPI.
  - To present a (partial or full) interface of typed input parameters 
  whose values can be set and overridden in Usd, to be provided later at 
  deformation-time as parameter values to the actual nodes. Node 
  input parameters are encapsulated in the property schema InputPort.
  '''
)
{
}

class "ConnectableAPI" (
    doc = """ConnectableAPI is an API schema that provides a common
  interface for creating outputs and making connections between nodes 
  parameters and outputs. The interface is common to all Graph schemas
  that support Inputs and Outputs, which currently includes Node,
  NodeGraph, and NodeComposer .

  One can construct a ConnectableAPI directly from a UsdPrim, or
  from objects of any of the schema classes listed above.  If it seems
  onerous to need to construct a secondary schema object to interact with
  Inputs and Outputs, keep in mind that any function whose purpose is either
  to walk shot description networks via their connections, or to create such
  networks, can typically be written entirely in terms of 
  ConnectableAPI objects, without needing to care what the underlying
  prim type is.

  Additionally, the most common ConnectableAPI behaviors
  (creating Inputs and Outputs, and making connections) are wrapped as
  convenience methods on the prim schema classes (creation) and 
  InputPort and OutputPort.
  """
)
{
}

class "ComposerBindingAPI" (
    doc = """ComposerBindingAPI is an API schema that provides an 
  interface for binding assets to different states(animation, cfx, cached...). 
  """
)
{
}

class "CoordSysAPI" (
    doc = '''CoordSysAPI provides a way to designate, name,
    and discover coordinate systems.

    Coordinate systems are implicitly established by UsdGeomXformable
    prims, using their local space.  That coordinate system may be
    bound (i.e., named) from another prim.  The binding is encoded
    as a single-target relationship in the "coordSys:" namespace.
    Coordinate system bindings apply to descendants of the prim
    where the binding is expressed, but names may be re-bound by
    descendant prims.

    Named coordinate systems are useful in animation workflows.
    An example is camera base sculpting.  
    Using the paint coordinate frame avoids the need to assign 
    a UV set to the object, and can be a concise way to project
    sculpt across a collection of objects with a single shared
    paint coordinate system.

    This is a non-applied API schema.
    '''
)
{
}

